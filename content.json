[{"title":"ViewPager Fragment 的无限循环","date":"2018-08-16T08:20:39.000Z","path":"2018/08/16/ViewPager-Fragment-的无限循环（一）/","text":"ViewPager Fragment 的无限循环 先来张美女养养神 前言，很早之前就想认真理解ViewPager和Fragment的使用，本文主要是在于记录，方便日后查看。 简单实现ViewPager + Fragment页面的转换 在main_activity布局文件中添加ViewPager控件： 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.example.mytablayout.viewpager.ViewPagerActivity\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 新建4个Fragment，分别为Fragment1、Fragment2、Fragment3、Fragment4，这四个Fragment内容都差不多，就不一一添出来了： 123456789101112131415161718192021222324 //布局内容 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:background=\"@color/blue\" android:textColor=\"@color/white\" android:textSize=\"40sp\" android:text=\"Fragment 1\"/&gt; &lt;/LinearLayout&gt; //java内容 public class Fragment1 extends Fragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_1,container,false); return view; &#125;&#125; 添加Fragment的设配器继承FragmentPagerAdapter： 12345678910111213141516 public class MyFragmentPagerAdapter extends FragmentPagerAdapter &#123; private FragmentManager fragmentManager; List&lt;Fragment&gt; fragments; public MyFragmentPagerAdapter(FragmentManager fm, List&lt;Fragment&gt; fragments) &#123; super(fm); this.fragments = fragments; &#125; @Override public int getCount() &#123; return fragments.size(); &#125; @Override public Fragment getItem(int position) &#123; return fragments.get(position); &#125;&#125; 在MainActivity中的代码实现： 123456789101112131415161718192021222324252627282930313233 public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; List&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;(); private static final String TAG = \"ViewPagerActivity\"; private ViewPager viewPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main_activity); viewPager = findViewById(R.id.viewpager); fragments.add(new Fragment1()); fragments.add(new Fragment2()); fragments.add(new Fragment3()); fragments.add(new Fragment4()); MyFragmentPagerAdapter myFragmentPagerAdapter = new MyFragmentPagerAdapter(getSupportFragmentManager(),fragments); viewPager.setAdapter(myFragmentPagerAdapter); viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; Log.d(TAG, \"onPageScrolled: \"); &#125; @Override public void onPageSelected(int position) &#123; Log.d(TAG, \"onPageSelected: \" + position); &#125; @Override public void onPageScrollStateChanged(int state) &#123; Log.d(TAG, \"onPageScrollStateChanged: \"); &#125; &#125;); &#125;&#125; 效果如下 如此，简单的转换页面的效果已经完成，从代码流程来分析一波，首先我们会去建造几个Fragment，通过集合List的泛型，把fragment对象加入集合中，通过适配器展示出来。","tags":[]},{"title":"RecyclerView-的介绍-三（自定义分割线）","date":"2018-08-13T06:42:19.000Z","path":"2018/08/13/RecyclerView-的介绍-三（自定义分割线）/","text":"RecyclerView的分割线** 从上一篇的之后，我们能完成一个基本的RecyclerView，今天主要来学习RecyclerView的分割线； &nbsp;&nbsp; RecyclerView中自带了一个默认的分割线的调用类，情况如下 1recyclerView.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL)) &nbsp;&nbsp; 因为这个默认的分割线样式太过于简陋，一般我们都会自定义一个分割线来实现我们的需求，下面我们开始自定义一个可以控制方向、颜色、高度的分割线 创建一个ColorDividerItemDecoration类，并继承RecyclerView.ItemDecoration； 使分割线、方向，画笔为全局变量； 12345private float mDividerHeight; private Paint mPaint; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private int mOrientation; 设置一个方向的有参构造方法，并在方法内初始化一些变量； 1234567891011121314public ColorDividerItemDecoration(int orientation) &#123; mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setColor(Color.RED); setOrientation(orientation); &#125; public void setOrientation(int orientation) &#123; if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST)&#123; throw new IllegalArgumentException(\"invalid orientation\"); &#125; mOrientation = orientation; &#125; 重写onDraw方法，判断屏幕横或纵时的逻辑； 123456789101112131415161718192021222324252627282930313233public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); if (mOrientation == VERTICAL_LIST)&#123; drawVertical(c,parent); &#125;else &#123; drawHorizontal(c,parent); &#125; &#125;private void drawVertical(Canvas c, RecyclerView parent) &#123; final float left = parent.getPaddingLeft(); final float right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); final float top = child.getBottom() + params.bottomMargin; final float bottom = top + mDividerHeight; c.drawRect(left,top,right,bottom,mPaint); &#125; &#125; private void drawHorizontal(Canvas c, RecyclerView parent) &#123; float top = parent.getPaddingTop(); float bottom = parent.getHeight() - parent.getPaddingBottom(); int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View child = parent.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); float left = child.getHeight() + params.rightMargin; float right = left + mDividerHeight; c.drawRect(left,top,right,bottom,mPaint); &#125; &#125; 重写getItemOffsets方法，设置item的padding的属性； 12345678@Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); if (parent.getChildAdapterPosition(view) != 0)&#123; outRect.top = 10; mDividerHeight = 10; &#125; &#125; 在mainActivity中调用； 12ColorDividerItemDecoration colorDividerItemDecoration = new ColorDividerItemDecoration(ColorDividerItemDecoration.VERTICAL_LIST);recyclerView.addItemDecoration(colorDividerItemDecoration); &nbsp;&nbsp;本人菜鸟一个，如有不对的地方，请帮忙指出，上面的难点主要在方向的绘制，通过获取到所有的item的个数，根据item的总数来遍历每一个item的位置，绘制出横或纵的分割线；","tags":[]},{"title":"RecyclerView-的介绍-二","date":"2018-07-18T03:43:14.000Z","path":"2018/07/18/RecyclerView-的介绍-二/","text":"RecyclerViewAdapter介绍 在上篇简单的介绍了RecyclerView的使用, 今天主要了解RecyclerViewAdapter 如果没有添加依赖包，一定要先添加； 1implementation 'com.android.support:recyclerview-v7:26.1.0' 创建一个命名为RecyclerViewAdapter的类，继承RecyclerView.Adapter&lt;RecyclerViewAdapter.MyViewHolder&gt;； 1public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.MyViewHolder&gt; 创建MyViewHolder:在Adapter中创建一个继承RecyclerView.ViewHolder的静态内部类，在类里主要初始化item的控件； 1234567class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public MyViewHolder(View itemView) &#123; super(itemView); tv = itemView.findViewById(R.id.tv_item); &#125; &#125; 必须重写onCreateViewHolder、onBindViewHolder、getItemCount这三个方法： onCreateViewHolder()&nbsp; 每生成一个Item时，inflater出一个View,但该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例。 123456 @Override public RecyclerViewAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout_item,parent,false); MyViewHolder holder = new MyViewHolder(view); return holder;&#125; onBindViewHolder()&nbsp; 这个方法主要用于渲染数据到View中。方法提供给你你一个viewHolder,而不是原来的convertView。 12345@Override public void onBindViewHolder(HomeAdapter.MyViewHolder holder, int position) &#123; holder.itemView.setTag(position); holder.tv.setText(mList.get(position)); &#125; getItemCOunt()&nbsp; 这个方法类似于BsaeAdapter的getCount,获取总共有多少个Item。 至此，到这里就结束了，如果上述有歧义的地方，请及时联系作者；这已经是第三篇了，虽然内容都很基础，但还是感到很充足，把自己学到的东西分享出去，很激动，兴奋，虽然有些微不足道；嘻嘻，加油，坚持！ 题外话，昨天晚上有点伤感吧，通过众筹得知一位小学同学得了白血病，虽然还是８年前的一次小学同学聚会看到过一次，但现在脑海里立马能呈现出当时那个阳光健康的大男孩；带着这份沉重的心情，看完了你在前几次化疗，从希望到失望，到现在的绝望，但你依然每次都不放过任何一个生存的希望，我为你骄傲，加油吧，老同学！ 眼睛进沙了，今天先到这了，下期再见 非淡泊无以明志 非宁静无以致远","tags":[]},{"title":"RecyclerView 的介绍(一)","date":"2018-07-13T09:55:09.000Z","path":"2018/07/13/RecyclerView-的介绍-一/","text":"美女镇楼 RecyclerView是什么？&nbsp;&nbsp;从android5.0开始，谷歌公司推出了一个用于大量数据展示的新控件RecyclerView，可以代替传统的ListView,它具有高度的解耦、异常灵活和更高的效率，通过设置它提供的不同的LayoutManager、ItemDecoration、ItemAnimator可是实现更加丰富多样的效果。 配置BUild.gradle&nbsp;&nbsp; 使用Recycleriew之前，我们得先导入support-v7包(android studio)12345dependencies&#123;... complie 'com.android.support:appcompat-v7:22.2.0' complie 'com.android.support:recyclerview-v7:22.2.0'&#125; 使用RecyclerView&nbsp;&nbsp; 修改main_activity.xml中的代码,具体如下1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp; 然后新建activity_recycler_view.xml如下：123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_item\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:background=\"@android:color/white\" /&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp; 和listView的Adapter相比，Adapter最大的改进就是对ViewHolder进行了封装定义再次，自定义一个ViewHolder继承RecyclerView.ViewHolder;下面来一个实例：12345678910111213141516171819202122232425262728293031323334353637383940414243public class HomeAdapter extends RecyclerView.Adapter&lt;HomeAdapter.MyViewHolder&gt; &#123; private List&lt;String&gt; mList; private Context mContext; public HomeAdapter(List&lt;String&gt; mList, Context mContext) &#123; this.mList = mList; this.mContext = mContext; &#125; public void removeData(int position)&#123; mList.remove(position); notifyItemRemoved(position); if (position != mList.size())&#123; notifyItemRangeChanged(position,mList.size() - position); &#125; &#125; @Override public HomeAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_recycler,parent,false); MyViewHolder holder = new MyViewHolder(view); return holder; &#125; @Override public void onBindViewHolder(HomeAdapter.MyViewHolder holder, int position) &#123; holder.itemView.setTag(position); holder.tv.setText(mList.get(position)); &#125; @Override public int getItemCount() &#123; return mList.size(); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public MyViewHolder(View itemView) &#123; super(itemView); tv = itemView.findViewById(R.id.tv_item); &#125; &#125;&#125; &nbsp;&nbsp;在mainActivity的onCreate方法中实例化RecyclerView、LinearLayoutManager、HomeAdapter,实例如下：1234567891011 RecyclerView recycler = findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this); HomeAdapter adapter = new HomeAdapter(mList,this);//默认条目样式为垂直排列layoutManager.setOrientation(LinearLayoutManager.VERTICAL);//条目样式为水平排列//layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); recycler.setLayoutManager(layoutManager);//设置Item增加和删除时的动画 recycler.setItemAnimator(new DefaultItemAnimator()); recycler.setAdapter(adapter); &nbsp;&nbsp; 最后显示效果如下: &nbsp;&nbsp; 至此，一个简单的RecyclerView就完成了，下一篇主要分析自定义Adapter中的重写方法，点击事件。今天暂时告一段落，下期不见不散。 &nbsp;&nbsp; 非淡泊无以明志 非宁静无以致远!","tags":[]},{"title":"android-Activity的生命周期详解","date":"2018-07-06T09:55:09.000Z","path":"2018/07/06/android-Activity的生命周期详解/","text":"美女镇楼 什么是activity?&nbsp;&nbsp;众所周知，activity是android的四大组件之一，它在Andeoid中代表了界面和以界面为中心的相应的业务逻辑，包括显示、与用户交互等。一个应用程序通常由多个activity组成，当用户打开的第一个界面我们称为activity，其中activity之间的通信是intent。今天我们主要了解的生命周期，下图是它从出生到销毁的全过程: 活动状态 运行状态：当一个活动位于返回栈的栈顶时，这时活动处于运行状态; 暂停状态：当一个活动不再处于栈顶位置时，但仍然可见时，这时活动就进入了暂停状态;(对话框形式) 停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态 销毁状态：当一个活动从返回栈中移除后就变成了销毁状态。 Activity的７个回调方法 onCreate()：该方法是在activity被创建时回调，它是生命周期的第一个回调方法，我们在创建activity的时候一般都要重写该方法，主要在其中做一些初始化的操作，如通过SetContentView设置界面布局资源，初始化所需要的控件。 onStart()：回调此方法时，表明activity已处于可见状态，只是还没有在前台显示，因此无法与用户进行交互。 onResume()：调用此方法时，则说明activity已在前台可见，可与用户交互了。它与onStrat()方法相同处是回调两者时，activity都是可见的，只是一个与用户不能交互，一个能与用户交互。 onPause()：回调此方法时，表示activity正在停止，如弹出一个框时，会执行onPause()-&gt;onStop()方法。 onstop()：回调此方法，一般在onPause()方法执行完后执行，表示activity即将停止或完全覆盖，此时activity不可见，仅在后台运行。 onDestroy()：回调此方法，说明activity正在被销毁，在此方法中我们一般做一些回收工作和最终资源的释放。 onRestart()：当activity正在重新启动，由不可见变成可见的状态时，回调此方法。 &nbsp;&nbsp; 上面７个方法中，除了onRestart(),其他都是两两相对的，如：onCreate和onDestroy(完整生存期)、onStart和onStop(可见生存期)、onResume和onPause(前台生存期)。 体验activity生命周期&nbsp;&nbsp; 屁话说了一大堆，下面我们通过一个实例来更直观的体验activity的生命周期。 &nbsp;&nbsp;首先我们新建一个项目，再分别创建两个子活动——NormalActivity和DialogActivity;创建完成之后，分别把normal_activity.xml和diglog_activity.xml里的代码替换如下内容;12345678910111213141516171819&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"This is a normal activity\"/&gt;&lt;/LinearLayout&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"This is a dialog activity\"/&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp;然后修改AndroidManifest.xml的配置android:theme=”@style/Theme.AppCompat.Dialog”1234567891011&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".NormalActivity\" /&gt; &lt;activity android:name=\".DialogActivity\" android:theme=\"@style/Theme.AppCompat.Dialog\"&gt; &lt;/activity&gt; &nbsp;&nbsp; 修改main_activity.xml,如下：1234567891011121314&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/start_normal_activity\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Start NormalActivity\" /&gt; &lt;Button android:id=\"@+id/start_dialog_activity\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Start DialogActivity\" /&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp;最后修改main_activity的代码，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainActivity extends AppCompatActivity &#123; private static final String TAG = \"MainActivity\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, \"onCreate: \"); setContentView(R.layout.activity_main); findViewById(R.id.start_normal_activity).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,NormalActivity.class)); &#125; &#125;); findViewById(R.id.start_dialog_activity).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,DialogActivity.class)); &#125; &#125;); &#125; @Override protected void onStart() &#123; super.onStart(); Log.d(TAG, \"onStart: \"); &#125; @Override protected void onResume() &#123; super.onResume(); Log.d(TAG, \"onResume: \"); &#125; @Override protected void onPause() &#123; super.onPause(); Log.d(TAG, \"onPause: \"); &#125; @Override protected void onStop() &#123; super.onStop(); Log.d(TAG, \"onStop: \"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.d(TAG, \"onDestroy: \"); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.d(TAG, \"onRestart: \"); &#125;&#125; &nbsp;&nbsp;现在运行这个程序，这是logcat中的打印日志，从下图可以看到程序开启后会执行onCreate() -&gt; onStart() -&gt; onResume()。 &nbsp;&nbsp;启动NormalActivity后，会把MainActivity完全遮住，因此执行onPause() -&gt; onStop(),此时不会执行onCreate(),因为activity没有重建。 &nbsp;&nbsp;点击返回键，返回MainActivity,执行onRestart() -&gt; onStart() -&gt; onResume() &nbsp;&nbsp;启动DialogActivity后,执行onPause()方法，因为DialogActivity并没有完全遮挡住MainActivity，此时MainActivity只是进入了暂停状态，并没有进入停止状态。 &nbsp;&nbsp;相应的，我们按下返回键,再一次返回MainActivity,这是只有onResume()方法会执行 &nbsp;&nbsp;最后，在MainActivity下按返回键退出程序，执行onPause() -&gt; onStop() -&gt; onDestroy()。 到这里我们来个小结：当Activity启动时，依次会调用onCreate(),onStart(),onResume()；当Activity退居后台时（不可见，被新的Activity完全覆盖），onPause()和onStop()会依次被调用；当Activity重新回到前台（或者被覆盖后又回到原Activity）时，onRestart()，onStart()，onResume()会依次被调用；当Activity退出销毁时（点击back键），onPause()，onStop()，onDestroy()会依次被调用，到此Activity的整个生命周期方法回调完成。至此，activity的生命周期以介绍完成，往后继续更新博客，对自己所学的知识进行梳理。加油！加油！ &nbsp;&nbsp; 非淡泊无以明志 非宁静无以致远","tags":[]}]