[{"title":"android-Activity的生命周期详解","date":"2018-07-16T10:23:38.701Z","path":"2018/07/16/android-Activity的生命周期详解/","text":"美女镇楼 什么是activity?&nbsp;&nbsp;众所周知，activity是android的四大组件之一，它在Andeoid中代表了界面和以界面为中心的相应的业务逻辑，包括显示、与用户交互等。一个应用程序通常由多个activity组成，当用户打开的第一个界面我们称为activity，其中activity之间的通信是intent。今天我们主要了解的生命周期，下图是它从出生到销毁的全过程: 活动状态 运行状态：当一个活动位于返回栈的栈顶时，这时活动处于运行状态; 暂停状态：当一个活动不再处于栈顶位置时，但仍然可见时，这时活动就进入了暂停状态;(对话框形式) 停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态 销毁状态：当一个活动从返回栈中移除后就变成了销毁状态。 Activity的７个回调方法 onCreate()：该方法是在activity被创建时回调，它是生命周期的第一个回调方法，我们在创建activity的时候一般都要重写该方法，主要在其中做一些初始化的操作，如通过SetContentView设置界面布局资源，初始化所需要的控件。 onStart()：回调此方法时，表明activity已处于可见状态，只是还没有在前台显示，因此无法与用户进行交互。 onResume()：调用此方法时，则说明activity已在前台可见，可与用户交互了。它与onStrat()方法相同处是回调两者时，activity都是可见的，只是一个与用户不能交互，一个能与用户交互。 onPause()：回调此方法时，表示activity正在停止，如弹出一个框时，会执行onPause()-&gt;onStop()方法。 onstop()：回调此方法，一般在onPause()方法执行完后执行，表示activity即将停止或完全覆盖，此时activity不可见，仅在后台运行。 onDestroy()：回调此方法，说明activity正在被销毁，在此方法中我们一般做一些回收工作和最终资源的释放。 onRestart()：当activity正在重新启动，由不可见变成可见的状态时，回调此方法。 &nbsp;&nbsp; 上面７个方法中，除了onRestart(),其他都是两两相对的，如：onCreate和onDestroy(完整生存期)、onStart和onStop(可见生存期)、onResume和onPause(前台生存期)。 体验activity生命周期&nbsp;&nbsp; 屁话说了一大堆，下面我们通过一个实例来更直观的体验activity的生命周期。 &nbsp;&nbsp;首先我们新建一个项目，再分别创建两个子活动——NormalActivity和DialogActivity;创建完成之后，分别把normal_activity.xml和diglog_activity.xml里的代码替换如下内容;12345678910111213141516171819&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"This is a normal activity\"/&gt;&lt;/LinearLayout&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"This is a dialog activity\"/&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp;然后修改AndroidManifest.xml的配置android:theme=”@style/Theme.AppCompat.Dialog”1234567891011&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".NormalActivity\" /&gt; &lt;activity android:name=\".DialogActivity\" android:theme=\"@style/Theme.AppCompat.Dialog\"&gt; &lt;/activity&gt; &nbsp;&nbsp; 修改main_activity.xml,如下：1234567891011121314&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/start_normal_activity\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Start NormalActivity\" /&gt; &lt;Button android:id=\"@+id/start_dialog_activity\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Start DialogActivity\" /&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp;最后修改main_activity的代码，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainActivity extends AppCompatActivity &#123; private static final String TAG = \"MainActivity\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, \"onCreate: \"); setContentView(R.layout.activity_main); findViewById(R.id.start_normal_activity).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,NormalActivity.class)); &#125; &#125;); findViewById(R.id.start_dialog_activity).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,DialogActivity.class)); &#125; &#125;); &#125; @Override protected void onStart() &#123; super.onStart(); Log.d(TAG, \"onStart: \"); &#125; @Override protected void onResume() &#123; super.onResume(); Log.d(TAG, \"onResume: \"); &#125; @Override protected void onPause() &#123; super.onPause(); Log.d(TAG, \"onPause: \"); &#125; @Override protected void onStop() &#123; super.onStop(); Log.d(TAG, \"onStop: \"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.d(TAG, \"onDestroy: \"); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.d(TAG, \"onRestart: \"); &#125;&#125; &nbsp;&nbsp;现在运行这个程序，这是logcat中的打印日志，从下图可以看到程序开启后会执行onCreate() -&gt; onStart() -&gt; onResume()。 &nbsp;&nbsp;启动NormalActivity后，会把MainActivity完全遮住，因此执行onPause() -&gt; onStop(),此时不会执行onCreate(),因为activity没有重建。 &nbsp;&nbsp;点击返回键，返回MainActivity,执行onRestart() -&gt; onStart() -&gt; onResume() &nbsp;&nbsp;启动DialogActivity后,执行onPause()方法，因为DialogActivity并没有完全遮挡住MainActivity，此时MainActivity只是进入了暂停状态，并没有进入停止状态。 &nbsp;&nbsp;相应的，我们按下返回键,再一次返回MainActivity,这是只有onResume()方法会执行 &nbsp;&nbsp;最后，在MainActivity下按返回键退出程序，执行onPause() -&gt; onStop() -&gt; onDestroy()。 到这里我们来个小结：当Activity启动时，依次会调用onCreate(),onStart(),onResume()；当Activity退居后台时（不可见，被新的Activity完全覆盖），onPause()和onStop()会依次被调用；当Activity重新回到前台（或者被覆盖后又回到原Activity）时，onRestart()，onStart()，onResume()会依次被调用；当Activity退出销毁时（点击back键），onPause()，onStop()，onDestroy()会依次被调用，到此Activity的整个生命周期方法回调完成。至此，activity的生命周期以介绍完成，往后继续更新博客，对自己所学的知识进行梳理。加油！加油！ &nbsp;&nbsp; 非淡泊无以明志 非宁静无以致远","tags":[]},{"title":"RecyclerView 的介绍(一)","date":"2018-07-13T09:55:09.000Z","path":"2018/07/13/RecyclerView-的介绍-一/","text":"美女镇楼 RecyclerView是什么？&nbsp;&nbsp;从android5.0开始，谷歌公司推出了一个用于大量数据展示的新控件RecyclerView，可以代替传统的ListView,它具有高度的解耦、异常灵活和更高的效率，通过设置它提供的不同的LayoutManager、ItemDecoration/ItemAnimator可是实现更加丰富多样的效果。 配置BUild.gradle&nbsp;&nbsp; 使用Recycleriew之前，我们得导入support-V7包12345dependencies&#123;... complie 'com.android.support:appcompat-v7:22.2.0' complie 'com.android.support:recyclerview-v7:22.1.0'&#125; # 使用RecyclerView &nbsp;&nbsp; 修改main_activity.xml中的代码,具体如下 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#f0f0\"/&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp; 然后新建activity_recycler_view.xml如下： 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_item\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:background=\"@android:color/white\" /&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp; 和listView的Adapter相比，Adapter最大的改进就是对ViewHolder进行了封装定义再次，自定义一个ViewHolder继承RecyclerView.ViewHolder;下面来一个实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class HomeAdapter extends RecyclerView.Adapter&lt;HomeAdapter.MyViewHolder&gt; &#123; private List&lt;String&gt; mList; private Context mContext; public HomeAdapter(List&lt;String&gt; mList, Context mContext) &#123; this.mList = mList; this.mContext = mContext; &#125; public void removeData(int position)&#123; mList.remove(position); notifyItemRemoved(position); if (position != mList.size())&#123; notifyItemRangeChanged(position,mList.size() - position); &#125; &#125; @Override public HomeAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_recycler,parent,false); MyViewHolder holder = new MyViewHolder(view); return holder; &#125; @Override public void onBindViewHolder(HomeAdapter.MyViewHolder holder, int position) &#123; holder.itemView.setTag(position); holder.tv.setText(mList.get(position)); &#125; @Override public int getItemCount() &#123; return mList.size(); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public MyViewHolder(View itemView) &#123; super(itemView); tv = itemView.findViewById(R.id.tv_item); &#125; &#125;&#125; &nbsp;&nbsp;在mainActivity的onCreate方法中实例化RecyclerView、LinearLayoutManager、HomeAdapter,实例如下： 123456789 RecyclerView recycler = findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this); HomeAdapter adapter = new HomeAdapter(mList,this);//默认条目样式为垂直排列layoutManager.setOrientation(LinearLayoutManager.VERTICAL); recycler.setLayoutManager(layoutManager);//设置Item增加和删除时的动画 recycler.setItemAnimator(new DefaultItemAnimator()); recycler.setAdapter(adapter); &nbsp;&nbsp; 最后显示效果如下: &nbsp;&nbsp; 至此，一个简单的RecyclerView就完成了，下一篇主要分析自定义Adapter中的重写方法，点击事件。今天暂时告一段落，下棋不见不散。 &nbsp;&nbsp; 非淡泊无以明志 非宁静无以致远","tags":[]},{"title":"新的开始","date":"2018-07-11T02:13:12.000Z","path":"2018/07/11/新的开始/","text":"","tags":[]},{"title":"Hello World","date":"2018-07-11T02:07:49.218Z","path":"2018/07/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]