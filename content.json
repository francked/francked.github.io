[{"title":"Android RxJava ： 创建操作符（基础篇）","date":"2018-11-22T08:40:28.000Z","path":"2018/11/22/Android-RxJava-：-创建操作符（基础篇）/","text":"#前言：很久没有写博客了，现在一篇很基础的博文，即RxJava这个库的使用；首先，让我们先理解它的定义； ##定义 ：基于事件流，实现异步操作的库； ##具体作用 ：实现了异步操作； ##使用方式 ：基于事件流的链式调用 ##优势： 逻辑简洁 实现优雅 使用简单","tags":[]},{"title":"一个使用MVP模式的登录注册的实现","date":"2018-10-09T06:48:53.000Z","path":"2018/10/09/一个使用MVP模式的登录注册的实现/","text":"MVP模式（Model View Presenter） 可以说是MVC模式（Model View Controller）在Android开发上的一种变种、进化模式；首先，我们先来了解MVC模式。 MVC模式它分为三部分，实体层（Model），视图层（View），以及控制层（Controller） View ：程序的UI界面，用于向用户展示数据以及接收用户的输入 Model ： JavaBean的实体类，用于保存实例数据 Controller ： 更新UI界面和数据实例 MVP模式 View ：负责图示部分展示，图示事件处理，Activity，Fragment，Dialog，ViewGroup等呈现视图的组件都可以承担该角色 Model ： 负责数据的请求，解析，过滤等数据操作 Presenter ： View和Model交互的桥梁 登录注册的实例 创建Model的接口 和Model类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public interface Imodel &#123; void Login(String account , String pass , LoginListener loginListener); void iRegister(String account , String pass , RegisterListener registerListener); interface RegisterListener&#123; void success(String msg); void fail(String msg); &#125; interface LoginListener&#123; void success(String msg); void fail(String msg); &#125;&#125;public class LoginModel implements Imodel&#123; private SQLiteUtil sqLiteUtil = SQLiteUtil.getInstances(); @Override public void Login(String account, String pass, LoginListener loginListener) &#123; if (account.equals(\"\") || account.isEmpty())&#123; loginListener.fail(\"账号不能为空\"); &#125; else if (pass.isEmpty() || pass.equals(\"\"))&#123; loginListener.fail(\"密码不能为空\"); &#125;else &#123; if (sqLiteUtil.queryUserAccountPass(account,pass))&#123; loginListener.success(\"登录成功\"); &#125;else &#123; loginListener.fail(\"账号或密码错误\"); &#125; &#125; &#125; @Override public void iRegister(String account, String pass, RegisterListener registerListener) &#123; if (account.equals(\"\") || account.isEmpty())&#123; registerListener.fail(\"账号不能为空\"); &#125;else &#123; //账号不存在 if (sqLiteUtil.queryUser(account)) &#123; if (pass.isEmpty() || pass.equals(\"\"))&#123; registerListener.fail(\"密码不能为空\"); &#125;else &#123; sqLiteUtil.add(account,pass); registerListener.success(\"注册成功\"); &#125; &#125; //账号存在 else &#123; registerListener.fail(\"账号已存在\"); &#125; &#125; &#125;&#125; 创建 BasePresenter，防止内存泄漏 1234567891011121314151617181920212223242526public class BasePresenter&lt;T&gt; &#123; //View 接口类型 弱引用 protected Reference&lt;T&gt; mViewRef; public void attachView(T view)&#123; //建立关联 mViewRef = new WeakReference&lt;T&gt;(view); &#125; protected T getView()&#123; return mViewRef.get(); //获取 View &#125; public boolean isViewAttached()&#123; //判断是否 与 View 建立关联 return mViewRef != null &amp;&amp; mViewRef.get() != null; &#125; public void detachView()&#123; //解除关联 if (mViewRef != null)&#123; mViewRef.clear(); mViewRef = null; &#125; &#125;&#125; 3.创建LoginPresenter、ILoginPresenter、IRegisterPresenter、RegisterPresenter类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public interface ILoginPresenter &#123; void Login();&#125;public interface IRegisterPresenter &#123; void register();&#125;public class LoginPresenter extends BasePresenter_2&lt;IView.LoginIView&gt; implements ILoginPresenter &#123; private static final String TAG = \"LoginPresenter\"; private LoginModel loginModel; private IView.LoginIView iView; public LoginPresenter(IView.LoginIView view) &#123; iView = view; loginModel = new LoginModel(); &#125; public void Login()&#123; loginModel.Login(iView.getAccount(), iView.getPass(), new Imodel.LoginListener() &#123; @Override public void success(String msg) &#123; iView.success(msg); Log.d(TAG, \"success: \"); &#125; @Override public void fail(String msg) &#123; iView.fail(msg); Log.d(TAG, \"fail: \"); &#125; &#125;); &#125;&#125;public class RegisterPresenter extends BasePresenter_2&lt;IView.RegisterIView&gt; implements IRegisterPresenter &#123; private static final String TAG = \"LoginPresenter\"; private LoginModel loginModel; private IView.RegisterIView iView; public RegisterPresenter(IView.RegisterIView view) &#123; iView = view; loginModel = new LoginModel(); &#125; @Override public void register() &#123; loginModel.iRegister(iView.getAccount(), iView.getPass(), new Imodel.RegisterListener() &#123; @Override public void success(String msg) &#123; iView.success(msg); &#125; @Override public void fail(String msg) &#123; iView.fail(msg); &#125; &#125;); &#125;&#125; 创建 IView 、LoginActivity 、 RegiserActivity、BaseActivity3个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171public abstract class BaseActivity &lt;V , T extends BasePresenter_2&lt;V&gt;&gt; extends AppCompatActivity &#123; private T presenter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(getLayoutResId()); initView(); initData(); presenter = bindPresenter(); presenter.attachView((V) this); &#125; protected abstract T bindPresenter(); @Override protected void onDestroy() &#123; super.onDestroy(); presenter.detachView(); &#125; public abstract int getLayoutResId(); //组件初始化 protected abstract void initView(); //页面初始化 页面数据 ， 在initView() 之后调用 protected abstract void initData();&#125;public interface IView &#123; interface LoginIView&#123; String getAccount(); String getPass(); void success(String msg); void fail(String msg); &#125; interface RegisterIView&#123; String getAccount(); String getPass(); void success(String msg); void fail(String msg); &#125;&#125;public class LoginActivity extends BaseActivity implements IView.LoginIView &#123; private static final String TAG = \"LoginActivity\"; private EditText et_account; private EditText et_pass; private Button bt_login; private Button bt_register; private LoginPresenter loginPresenter; @Override protected void initView() &#123; et_account = findViewById(R.id.account); et_pass = findViewById(R.id.pass); bt_login = findViewById(R.id.login_btn); bt_register = findViewById(R.id.register_btn); &#125; @Override protected void initData() &#123; bt_login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; loginPresenter.Login(); &#125; &#125;); bt_register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(LoginActivity.this, RegisterActivity.class)); &#125; &#125;); &#125; @Override protected BasePresenter_2 bindPresenter() &#123; loginPresenter = new LoginPresenter(this); return loginPresenter; &#125; @Override public int getLayoutResId() &#123; return R.layout.login_ui; &#125; @Override public String getAccount() &#123; return et_account.getText().toString().trim(); &#125; @Override public String getPass() &#123; return et_pass.getText().toString().trim(); &#125; @Override public void success(String msg) &#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); &#125; @Override public void fail(String msg) &#123; Log.d(TAG, \"fail: \" + msg); Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); &#125;public class RegisterActivity extends BaseActivity implements IView.RegisterIView &#123; private EditText re_account; private EditText re_pass; private Button bt_register; private RegisterPresenter presenter; @Override protected BasePresenter_2 bindPresenter() &#123; presenter = new RegisterPresenter(this); return presenter; &#125; @Override public int getLayoutResId() &#123; return R.layout.register_ui; &#125; @Override protected void initView() &#123; re_account = findViewById(R.id.account); re_pass = findViewById(R.id.pass); bt_register = findViewById(R.id.register); &#125; @Override protected void initData() &#123; bt_register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; presenter.register(); &#125; &#125;); &#125; @Override public String getAccount() &#123; return re_account.getText().toString().trim(); &#125; @Override public String getPass() &#123; return re_pass.getText().toString().trim(); &#125; @Override public void success(String msg) &#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); &#125; @Override public void fail(String msg) &#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); &#125; @Override public void onBackPressed() &#123; super.onBackPressed(); finish(); &#125;&#125; GreenDao 数据库的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165@Entitypublic class User &#123; @Id(autoincrement = true) private Long id; private String account; private String pass; @Generated(hash = 1710298536) public User(Long id, String account, String pass) &#123; this.id = id; this.account = account; this.pass = pass; &#125; @Generated(hash = 586692638) public User() &#123; &#125; public Long getId() &#123; return this.id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getAccount() &#123; return this.account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public String getPass() &#123; return this.pass; &#125; public void setPass(String pass) &#123; this.pass = pass; &#125;&#125;public class AppAppcation extends Application &#123; private DaoMaster.DevOpenHelper mHelper; private SQLiteDatabase db; private DaoMaster mDaoMaster; private DaoSession mDaoSession; private static AppAppcation instances; @Override public void onCreate() &#123; super.onCreate(); instances = this; setDatabase(); &#125; //单利模式 public static AppAppcation getInstances()&#123; return instances; &#125; public void setDatabase()&#123; mHelper = new DaoMaster.DevOpenHelper(this,\"user-db\",null); db = mHelper.getWritableDatabase(); mDaoMaster = new DaoMaster(db); mDaoSession = mDaoMaster.newSession(); &#125; public DaoSession getmDaoSession()&#123; return mDaoSession; &#125; public SQLiteDatabase getDb()&#123; return db; &#125;&#125;//对表进行操作public class SQLiteUtil &#123; private static SQLiteUtil instances; UserDao userDao; DaoSession daoSession; private static final String TAG = \"SQLiteUtil\"; public static SQLiteUtil getInstances() &#123; if (instances == null)&#123; synchronized (SQLiteUtil.class)&#123; if (instances == null)&#123; instances = new SQLiteUtil(); &#125; &#125; &#125; return instances; &#125; public SQLiteUtil() &#123; userDao = AppAppcation.getInstances().getmDaoSession().getUserDao(); daoSession = AppAppcation.getInstances().getmDaoSession(); &#125; //增加 public void add(String account , String pass)&#123; User user = new User(); user.setAccount(account); user.setPass(pass); userDao.insert(user); &#125; //删除 public void delete(User user)&#123; userDao.delete(user); &#125; //修改 public void updateContacts(User user)&#123; userDao.update(user); &#125; //删除表中内容 public void deleteAllContact() &#123; userDao.deleteAll(); &#125; //查询 是否存在 此账号 public boolean queryUser(String account)&#123; List list = userDao.queryBuilder().where(UserDao.Properties.Account.eq(account)).list(); if ( list.isEmpty())&#123; //返回 false 账号不存在 return true; &#125; //返回 true 账号存在 return false; &#125; public List&lt;User&gt; queryUserList()&#123; QueryBuilder&lt;User&gt; qb = userDao.queryBuilder(); List&lt;User&gt; list = qb.list(); return list; &#125; //查询 账号 密码 是否在数据库中 public boolean queryUserAccountPass(String account , String pass)&#123; if (queryUser(account))&#123; Log.d(TAG, \"queryUserAccountPass: 不存在\"); return false; &#125;else &#123; List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Account.eq(account)).list(); User user = list.get(0); if (user.getPass().equals(pass))&#123; Log.d(TAG, \"queryUserAccountPass: 密码相同\"); return true; &#125;else &#123; Log.d(TAG, \"queryUserAccountPass: 密码不相同\"); return false; &#125; &#125; &#125;&#125; 自己的理解回顾登录注册，从中可以看到view的绘制与model的业务逻辑处理是通过Presenter来交互的，可以得出model内的业务逻辑已经完全解耦了，例如，model实现了Imodel接口，重写了Login方法，参数为账号，密码，登录状态的接口对象，在View中实现IView接口，接口方法中主要是获取账号，密码数据，最后，在Presenter中，获得IView接口对象，model对象，写个登录方法，参数可以从IView对象去获取，登录状态的获取在匿名内部类获取。","tags":[]},{"title":"Retrofit+RxJava简单用法","date":"2018-09-13T08:04:09.000Z","path":"2018/09/13/Retrofit-RxJava简单用法/","text":"基本用法 在build.gradle文件中添加1234567//only Retrofit（只用Retrofit联网）compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0'//Rxjava and Retrofit（Retrofit+Rx需要添加的依赖）compile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'compile 'io.reactivex:rxandroid:1.2.1'compile 'io.reactivex:rxjava:1.2.1' 注意 ：一定要在AndroidManifest文件中添加网络权限，如未添加，程序不会报停止运行的错误，打印log走onError(Throwable e)方法。 把获得的json使用JsonFormat得到GanHuo实体类 123456789101112131415161718192021222324252627public class GanHuo &#123; /** * error : false * results : [&#123;&quot;_id&quot;:&quot;5b9771a29d212206c1b383d0&quot;,&quot;createdAt&quot;:&quot;2018-09-11T07:41:22.491Z&quot;,&quot;desc&quot;:&quot;2018-09-11&quot;,&quot;publishedAt&quot;:&quot;2018-09-11T00:00:00.0Z&quot;,&quot;source&quot;:&quot;web&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;https://ws1.sinaimg.cn/large/0065oQSqly1fv5n6daacqj30sg10f1dw.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshanmx&quot;&#125;,&#123;&quot;_id&quot;:&quot;5b830bba9d2122031f86ee51&quot;,&quot;createdAt&quot;:&quot;2018-08-27T04:21:14.703Z&quot;,&quot;desc&quot;:&quot;2018-08-27&quot;,&quot;publishedAt&quot;:&quot;2018-08-28T00:00:00.0Z&quot;,&quot;source&quot;:&quot;web&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;https://ws1.sinaimg.cn/large/0065oQSqly1fuo54a6p0uj30sg0zdqnf.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshanmx&quot;&#125;,&#123;&quot;_id&quot;:&quot;5b7b836c9d212201e982de6e&quot;,&quot;createdAt&quot;:&quot;2018-08-21T11:13:48.989Z&quot;,&quot;desc&quot;:&quot;2018-08-21&quot;,&quot;publishedAt&quot;:&quot;2018-08-21T00:00:00.0Z&quot;,&quot;source&quot;:&quot;web&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;https://ws1.sinaimg.cn/large/0065oQSqly1fuh5fsvlqcj30sg10onjk.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshanmx&quot;&#125;,&#123;&quot;_id&quot;:&quot;5b74e9409d21222c52ae4cb4&quot;,&quot;createdAt&quot;:&quot;2018-08-16T11:02:24.289Z&quot;,&quot;desc&quot;:&quot;2018-08-16&quot;,&quot;publishedAt&quot;:&quot;2018-08-16T00:00:00.0Z&quot;,&quot;source&quot;:&quot;api&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;https://ws1.sinaimg.cn/large/0065oQSqly1fubd0blrbuj30ia0qp0yi.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshan&quot;&#125;,&#123;&quot;_id&quot;:&quot;5b7102749d2122341d563844&quot;,&quot;createdAt&quot;:&quot;2018-08-13T12:00:52.458Z&quot;,&quot;desc&quot;:&quot;2018-08-13&quot;,&quot;publishedAt&quot;:&quot;2018-08-13T00:00:00.0Z&quot;,&quot;source&quot;:&quot;api&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;https://ww1.sinaimg.cn/large/0065oQSqly1fu7xueh1gbj30hs0uwtgb.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshan&quot;&#125;,&#123;&quot;_id&quot;:&quot;5b6bad449d21226f45755582&quot;,&quot;createdAt&quot;:&quot;2018-08-09T10:56:04.962Z&quot;,&quot;desc&quot;:&quot;2018-08-09&quot;,&quot;publishedAt&quot;:&quot;2018-08-09T00:00:00.0Z&quot;,&quot;source&quot;:&quot;web&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;https://ww1.sinaimg.cn/large/0065oQSqgy1fu39hosiwoj30j60qyq96.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshanmx&quot;&#125;,&#123;&quot;_id&quot;:&quot;5b67b7fd9d2122195bdbd806&quot;,&quot;createdAt&quot;:&quot;2018-08-06T10:52:45.809Z&quot;,&quot;desc&quot;:&quot;2018-08-06&quot;,&quot;publishedAt&quot;:&quot;2018-08-06T00:00:00.0Z&quot;,&quot;source&quot;:&quot;api&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;https://ww1.sinaimg.cn/large/0065oQSqly1ftzsj15hgvj30sg15hkbw.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshan&quot;&#125;,&#123;&quot;_id&quot;:&quot;5b63cd4e9d21225e0d3f58c9&quot;,&quot;createdAt&quot;:&quot;2018-08-03T11:34:38.672Z&quot;,&quot;desc&quot;:&quot;2018-08-03&quot;,&quot;publishedAt&quot;:&quot;2018-08-03T00:00:00.0Z&quot;,&quot;source&quot;:&quot;api&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;https://ww1.sinaimg.cn/large/0065oQSqgy1ftwcw4f4a5j30sg10j1g9.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshan&quot;&#125;,&#123;&quot;_id&quot;:&quot;5b6151509d21225206860f08&quot;,&quot;createdAt&quot;:&quot;2018-08-01T14:21:04.556Z&quot;,&quot;desc&quot;:&quot;2018-08-01&quot;,&quot;publishedAt&quot;:&quot;2018-08-01T00:00:00.0Z&quot;,&quot;source&quot;:&quot;api&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;https://ww1.sinaimg.cn/large/0065oQSqly1ftu6gl83ewj30k80tites.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshan&quot;&#125;,&#123;&quot;_id&quot;:&quot;5b60356a9d212247776a2e0e&quot;,&quot;createdAt&quot;:&quot;2018-07-31T18:09:46.825Z&quot;,&quot;desc&quot;:&quot;2018-07-31&quot;,&quot;publishedAt&quot;:&quot;2018-07-31T00:00:00.0Z&quot;,&quot;source&quot;:&quot;api&quot;,&quot;type&quot;:&quot;福利&quot;,&quot;url&quot;:&quot;http://ww1.sinaimg.cn/large/0065oQSqgy1ftt7g8ntdyj30j60op7dq.jpg&quot;,&quot;used&quot;:true,&quot;who&quot;:&quot;lijinshan&quot;&#125;] */ private boolean error; private List&lt;ResultsBean&gt; results; public boolean isError() &#123; return error; &#125; public void setError(boolean error) &#123; this.error = error; &#125; public List&lt;ResultsBean&gt; getResults() &#123; return results; &#125; public void setResults(List&lt;ResultsBean&gt; results) &#123; this.results = results; &#125;&#125; 创建一个接口类（GanHuoApi） 12@GET(&quot;福利/&#123;count&#125;/&#123;page&#125;&quot;)Observable&lt;GanHuo&gt; getGrilImage(@Path(&quot;count&quot;) int count,@Path(&quot;page&quot;) int page); 创建一个Retrofit的工具类（RetrofitUtil） 12345678910public class RetrofitUtil &#123; public static GanHuoApi getGanHuoApi()&#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://gank.io/api/data/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); return retrofit.create(GanHuoApi.class); &#125;&#125; 在mainActivity中的点击事件中获得网络请求数据 123456789101112131415161718192021222324RetrofitUtil.getGanHuoApi().getGrilImage(10,1).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;GanHuo&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"onError: \"); &#125; @Override public void onNext(GanHuo ganHuo) &#123; List&lt;ResultsBean&gt; list = ganHuo.getResults(); for (ResultsBean bean: list) &#123; Log.d(TAG, \"onNext: \" + bean.getUrl()); Log.d(TAG, \"onNext: \" + bean.getType()); &#125; &#125; &#125;); &#125; 打印结果： 123456789101112131415161718192009-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: https://ws1.sinaimg.cn/large/0065oQSqly1fv5n6daacqj30sg10f1dw.jpg09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: https://ws1.sinaimg.cn/large/0065oQSqly1fuo54a6p0uj30sg0zdqnf.jpg09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: https://ws1.sinaimg.cn/large/0065oQSqly1fuh5fsvlqcj30sg10onjk.jpg09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: https://ws1.sinaimg.cn/large/0065oQSqly1fubd0blrbuj30ia0qp0yi.jpg09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: https://ww1.sinaimg.cn/large/0065oQSqly1fu7xueh1gbj30hs0uwtgb.jpg09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: https://ww1.sinaimg.cn/large/0065oQSqgy1fu39hosiwoj30j60qyq96.jpg09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利09-13 15:54:39.258 26123-26123/com.example.myrxjava D/MainActivity: onNext: https://ww1.sinaimg.cn/large/0065oQSqly1ftzsj15hgvj30sg15hkbw.jpg09-13 15:54:39.259 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利09-13 15:54:39.259 26123-26123/com.example.myrxjava D/MainActivity: onNext: https://ww1.sinaimg.cn/large/0065oQSqgy1ftwcw4f4a5j30sg10j1g9.jpg09-13 15:54:39.259 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利09-13 15:54:39.259 26123-26123/com.example.myrxjava D/MainActivity: onNext: https://ww1.sinaimg.cn/large/0065oQSqly1ftu6gl83ewj30k80tites.jpg09-13 15:54:39.259 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利09-13 15:54:39.259 26123-26123/com.example.myrxjava D/MainActivity: onNext: http://ww1.sinaimg.cn/large/0065oQSqgy1ftt7g8ntdyj30j60op7dq.jpg09-13 15:54:39.259 26123-26123/com.example.myrxjava D/MainActivity: onNext: 福利","tags":[]},{"title":"room 数据库的使用","date":"2018-09-07T09:12:03.000Z","path":"2018/09/07/room-数据库的使用/","text":"Room持久性库提供了SQLite的抽象层，以便在充分利用SQLite的同时允许流畅的数据库访问。 笔记：记录room数据库的基本操作，主要记录Rxecutor的使用。 基本用法 配置build.gradle 12implementation 'android.arch.persistence.room:runtime:1.0.0' annotationProcessor 'android.arch.persistence.room:compiler:1.0.0' 创建User实体类 和UserDao接口（增更删改数据库），使用@Dao注解该接口，@Insert, @Update, @Delete,@Query代表我们常用的插入、更新、删除、查询数据库操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Entitypublic class User &#123; @PrimaryKey(autoGenerate = true) private int id; private String name; private String password; private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", password='\" + password + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125;@Daopublic interface UserDao &#123; @Query(\"SELECT * FROM user\") List&lt;User&gt; getAllUsers(); @Query(\"SELECT * FROM user where name like :name\") User getUser(String name); @Insert void insert(User... users); @Query(\"delete from User\") void deletes(); @Query(\"delete from User where name like:name\") void delete(String name);&#125; 分析：在类前记得注解，例如：User类注解@Entity，UserDao类注解@Dao 创建数据库1234567891011121314151617181920212223@Database(entities = &#123;User.class&#125;,version = 1,exportSchema = false)public abstract class UserDatabase extends RoomDatabase &#123; private static final String DB_NAME = \"UserDatabase.db\"; private static volatile UserDatabase instance; static synchronized UserDatabase getInstance(Context context) &#123; if (instance == null)&#123; instance = create(context); &#125; return instance; &#125; private static UserDatabase create(final Context context)&#123; return Room.databaseBuilder( context, UserDatabase.class, DB_NAME ).build(); &#125; public abstract UserDao getUserDao();&#125; 分析：这里我们使用了@Database来注解该类，entities为添加表名，version为版本号 ，还需要添加exportSchema = false，否则会报警告。Error:(10, 17) 警告: Schema export directory is not provided to the annotation processor so we cannot export the schema. You can either provide room.schemaLocation annotation processor argument OR set exportSchema to false. 使用数据库，由于所有操作必须在后台线程中完成，这里创建了一个AppExecutor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class AppExecutor &#123; private static final int THREAD_COUNT = 3; private Executor mDiskIO; private Executor mNetWorkIO; private Executor mMainThread; public AppExecutor(Executor mDiskIO, Executor mNetWorkIO, Executor mMainThread) &#123; this.mDiskIO = mDiskIO; this.mNetWorkIO = mNetWorkIO; this.mMainThread = mMainThread; &#125; public AppExecutor() &#123; this(new DiskIOThreadExector() , Executors.newFixedThreadPool(THREAD_COUNT) ,new MainThreadExcetor()); &#125; public Executor getmDiskIO() &#123; return mDiskIO; &#125; public Executor getmNetWorkIO() &#123; return mNetWorkIO; &#125; public Executor getmMainThread() &#123; return mMainThread; &#125; private static class MainThreadExcetor implements Executor&#123; private Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(@NonNull Runnable command) &#123; handler.post(command); &#125; &#125; public static class DiskIOThreadExector implements Executor &#123; private final Executor dislIO; public DiskIOThreadExector() &#123; this.dislIO = Executors.newSingleThreadExecutor(); &#125; @Override public void execute(@NonNull Runnable runnable) &#123; dislIO.execute(runnable); &#125; &#125;&#125; 创建一个UserDataSoure接口类来封装UserDao 1234567891011121314151617181920212223public interface UserDataSource &#123; interface LoadUserListCallback&#123; void onUserLoaded(List&lt;User&gt; users); void onDataNotAvailable(); &#125; interface LoadUserCallback&#123; void onUserLoaded(User user); void onDataNotAvailable(); &#125; void addUser(User user); void getUsers(LoadUserListCallback callback); void getUser(String name,LoadUserCallback callback); void deleteUsers(); void deleteUser(String name);&#125; 创建RemoteUserDataSource 和 UserRepository 类都实现UserDataSource 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class RemoteUserDataSource implements UserDataSource &#123; private static volatile RemoteUserDataSource INSTANCE = null; private UserDao userDao; private List&lt;User&gt; users; private User user; private AppExecutor appExecutor; public RemoteUserDataSource(AppExecutor appExecutor,UserDao userDao) &#123; this.userDao = userDao; this.appExecutor = appExecutor; &#125; public static RemoteUserDataSource getInstance(AppExecutor appExecutor, UserDao userDao) &#123; if (INSTANCE == null)&#123; synchronized (RemoteUserDataSource.class)&#123; INSTANCE = new RemoteUserDataSource(appExecutor,userDao); &#125; &#125; return INSTANCE; &#125; @Override public void addUser(final User user) &#123; appExecutor.getmDiskIO().execute(new Runnable() &#123; @Override public void run() &#123; userDao.insert(user); &#125; &#125;); &#125; @Override public void getUsers(final LoadUserListCallback callback) &#123; appExecutor.getmDiskIO().execute(new Runnable() &#123; @Override public void run() &#123; users = userDao.getAllUsers(); appExecutor.getmDiskIO().execute(new Runnable() &#123; @Override public void run() &#123; if (users.isEmpty())&#123; if (callback != null)&#123; callback.onDataNotAvailable(); &#125; &#125;else &#123; if (callback != null)&#123; callback.onUserLoaded(users); &#125; &#125; &#125; &#125;); &#125; &#125;); &#125; @Override public void getUser(final String name , final LoadUserCallback callback) &#123; appExecutor.getmDiskIO().execute(new Runnable() &#123; @Override public void run() &#123; user = userDao.getUser(name); appExecutor.getmMainThread().execute(new Runnable() &#123; @Override public void run() &#123; if (user != null)&#123; if (callback != null)&#123; callback.onUserLoaded(user); &#125; &#125;else &#123; if (callback != null)&#123; callback.onDataNotAvailable(); &#125; &#125; &#125; &#125;); &#125; &#125;); &#125; @Override public void deleteUsers() &#123; appExecutor.getmDiskIO().execute(new Runnable() &#123; @Override public void run() &#123; userDao.deletes(); &#125; &#125;); &#125; @Override public void deleteUser(final String name) &#123; appExecutor.getmDiskIO().execute(new Runnable() &#123; @Override public void run() &#123; userDao.delete(name); &#125; &#125;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class UserRepository implements UserDataSource &#123; private static UserRepository INSTANCE = null; private RemoteUserDataSource mRemoteUserDataSource; public UserRepository(RemoteUserDataSource remoteUserDataSource) &#123; mRemoteUserDataSource = remoteUserDataSource; &#125; public static UserRepository getInstance(RemoteUserDataSource remoteUserDataSource) &#123; if (INSTANCE == null)&#123; INSTANCE = new UserRepository(remoteUserDataSource); &#125; return INSTANCE; &#125; @Override public void addUser(User user) &#123; mRemoteUserDataSource.addUser(user); &#125; @Override public void getUsers(LoadUserListCallback callback) &#123; mRemoteUserDataSource.getUsers(callback); &#125; @Override public void getUser(String name, LoadUserCallback callback) &#123; mRemoteUserDataSource.getUser(name,callback); &#125; @Override public void deleteUsers() &#123; mRemoteUserDataSource.deleteUsers(); &#125; @Override public void deleteUser(String name) &#123; mRemoteUserDataSource.deleteUser(name); &#125;&#125; 获得UserRepository 实例化对象 123456public class UserInjection &#123; public static UserRepository getInstance(Context context)&#123; UserDatabase userDatabase = UserDatabase.getInstance(context); return UserRepository.getInstance(RemoteUserDataSource.getInstance(new AppExecutor(),userDatabase.getUserDao())); &#125;&#125; 实例简单的增差删操作： 1234567891011121314151617181920212223242526272829303132333435userRepository = UserInjection.getInstance(this); findViewById(R.id.add).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; User user = new User(); user.setName(\"张1\"); user.setPassword(\"张1\"); user.setAge(12); userRepository.addUser(user); &#125; &#125;); findViewById(R.id.query).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; userRepository.getUser(\"张1\", new UserDataSource.LoadUserCallback() &#123; @Override public void onUserLoaded(User user) &#123; Log.d(TAG, \"onUserLoaded: \" + user.toString()); &#125; @Override public void onDataNotAvailable() &#123; Log.d(TAG, \"onDataNotAvailable: 失败\"); &#125; &#125;); &#125; &#125;); findViewById(R.id.delete).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; userRepository.deleteUser(\"张1\"); &#125; &#125;);","tags":[]},{"title":"Retrofit2.0网络数据缓存小栗子","date":"2018-08-31T07:53:17.000Z","path":"2018/08/31/Retrofit2-0网络数据缓存小栗子/","text":"Retrofit2.0 拦截器这几天初步理解了下Retrofit2.0，在接触到拦截器时，深深的被他的功能给吸引住了，从此不可自拔，O(∩_∩)O哈哈~。由于本人深感记忆力跟不上，特此在这里留下笔记。 首先拦截器是什么 他是一种能够监控、重写、重试调用的机制，在通常情况下，拦截器用来添加、移除、转换请求和响应的头部信息。比如将域名替换为IP地址，在请求头中添加host属性，也可以添加我们应用中的一些公共参数，比如设备id、版本号，等等。 添加权限和添加包12&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt; 12implementation 'com.squareup.retrofit2:retrofit:2.1.0'implementation 'com.squareup.retrofit2:converter-gson:2.1.0' 由于Retrofit2.0并没有对于拦截器的处理，于是还得在OkHttp中去处理拦截器的问题，然后将okhttp对象add到Retrofit初始化的代码中 编写一个网络请求的接口 123456public interface GankApi &#123; @GET(\"data/&#123;type&#125;/&#123;count&#125;/&#123;page&#125;\") Call&lt;GankResEntity&gt; getGanHuo(@Path(\"type\") String type, @Path(\"count\") int count, @Path(\"page\") int page);&#125; 再创建一个类OkHttpProvider 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class OkHttpProvider &#123; private static final String TAG = \"OkHttpProvider\"; //最大连接时间 private static final long DEFAULT_CONNECT_TIMEOUT = 10; private static final long DEFAULT_WRITE_TIMEOUT = 15; private static final long DEFAULT_READ_TIMEOUT = 15; public static OkHttpClient getCacheOkHttpClient()&#123; return getOkHttpClient(new CacheControlInterceptor()); &#125; private static OkHttpClient getOkHttpClient(Interceptor cacheControl)&#123; //定制OkHttp OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder(); //设置超时时间 httpClientBuilder.connectTimeout(DEFAULT_CONNECT_TIMEOUT, TimeUnit.SECONDS); httpClientBuilder.connectTimeout(DEFAULT_WRITE_TIMEOUT, TimeUnit.SECONDS); httpClientBuilder.connectTimeout(DEFAULT_READ_TIMEOUT, TimeUnit.SECONDS); //设置缓存 File httpCacheDirectory = new File(FileUtil.getAppRootDirectoryPath(),\"OkHttpCache\"); httpClientBuilder.cache(new Cache(httpCacheDirectory,100*1024*1024)); //设置拦截器 httpClientBuilder.addInterceptor(new LoggingInterceptor()); httpClientBuilder.addInterceptor(cacheControl); return httpClientBuilder.build(); &#125; /** * 没有网络的情况下就从缓存中取 * 有网络的情况则从网络获取 */ private static class CacheControlInterceptor implements Interceptor&#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); if (!NetworkUtils.isConnected(GankAppcation.getmInstance()))&#123; request = request.newBuilder() .cacheControl(CacheControl.FORCE_CACHE) .build(); &#125; Response response = chain.proceed(request); if (NetworkUtils.isConnected(GankAppcation.getmInstance()))&#123; int maxAge = 60 * 60 * 2;//默认缓存2个小时 String cacheControl = request.cacheControl().toString(); if (TextUtils.isEmpty(cacheControl))&#123; cacheControl = \"public,max-age=\" + maxAge; &#125; response = response.newBuilder() .removeHeader(\"Pragma\") .header(\"Cache-Control\",cacheControl) .build(); &#125;else &#123; int maxStale = 60 * 60 * 24 * 30; response = response.newBuilder() .removeHeader(\"Pragma\") .header(\"Cache-Control\",\"publoc,only-is-cached, max-stale=\"+maxStale) .build(); &#125; return response; &#125; &#125; private static class LoggingInterceptor implements Interceptor&#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); long t1 = System.nanoTime(); LogUtils.d(TAG,String.format(Locale.CHINA,\"发送 request %s on %s%n%s\",request.url(),chain.connection(),request.headers())); Response response = chain.proceed(request); long t2 = System.nanoTime(); LogUtils.d(TAG, String.format(Locale.CHINA, \"收到 response for %s in %.1fms ，数据来自%s%n\", response.request().url(), (t2 - t1) / 1e6d, (response.cacheResponse() != null ? \"缓存\" : \"网络\"))); return response; &#125; &#125;&#125; 在这个类中，我创建了2个拦截器CacheControlInterceptor和LoggingInterceptor，CacheControlInterceptor顾名思义判断网络连接时，保存缓存的数据，未连接时，从网络上获取。第2个主要是log信息是否使用了缓存机制，response.cacheResponse() 。 根据OkHttpProvider，我们可以获得OkHttpClient，下一步创建RetrofitHelper类，来获取Retorfit返回的对象 12345678910111213141516171819202122232425public class RetrofitHelper &#123; private static OkHttpClient mOkHttpClient; private static Gson mGson; private static void init()&#123; mGson = new GsonBuilder() .setDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\") .serializeNulls() .create(); HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor(); interceptor.setLevel(HttpLoggingInterceptor.Level.BODY); mOkHttpClient = OkHttpProvider.getCacheOkHttpClient(); &#125; static Retrofit newRetorfit(String baseUrl)&#123; if (mOkHttpClient == null || mGson == null)&#123; init(); &#125; return new Retrofit.Builder() .baseUrl(baseUrl) .client(mOkHttpClient) .addConverterFactory(GsonConverterFactory.create(mGson)) .build(); &#125;&#125; 创建一个把请求数据封装在GankPresenter类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class GankPresenter &#123; private static final String TAG = \"GankPresenter\"; //干货类型 public static final String TYPE_ANDROID = \"Android\"; public static final String TYPE_WEB = \"前端\"; public static final String TYPE_RECOMMENT = \"瞎推荐\"; public static final String TYPE_IOS = \"iOS\"; public static final String TYPE_VIDEO = \"休息视频\"; public static final String TYPE_MEIZI = \"福利\"; public static final String TYPE_APP = \"App\"; public static final String TYPE_OTHER = \"拓展资源\"; //默认每次只能加载 10个数据 private static final int DEFAULT_LOAD_COUNTS = 10; private static Gson sGson = new GsonBuilder() .setDateFormat(\"yyyy-MM-dd HH:mm:SS\") .serializeNulls() .create(); private static GankApi getGankApi()&#123; return GankSingletion.mInstance; &#125; public static void getSpecifyGanHuo(final String type, int page , final RetorfitListener&lt;List&lt;GanHuo&gt;&gt; callback)&#123; getGankApi().getGanHuo(type,DEFAULT_LOAD_COUNTS,page).enqueue(new Callback&lt;GankResEntity&gt;() &#123; @Override public void onResponse(Call&lt;GankResEntity&gt; call, Response&lt;GankResEntity&gt; response) &#123; if (response.isSuccessful())&#123; LogUtils.d(TAG, type + \"干货下载成功： \" + response.body().toString()); Object results = response.body().getResults(); Type t = new TypeToken&lt;List&lt;GanHuo&gt;&gt;() &#123; &#125;.getType(); List&lt;GanHuo&gt; data = sGson.fromJson(sGson.toJson(results), t); callback.onSuccess(data); &#125;else &#123; LogUtils.e(TAG, type + \"干货下载失败，code： \" + response.code()); callback.onError(\"请求失败，code: \" + response.code()); &#125; &#125; @Override public void onFailure(Call&lt;GankResEntity&gt; call, Throwable t) &#123; LogUtils.e(TAG,type + \"干货下载失败\", t); callback.onError(t.getMessage()); &#125; &#125;); &#125; private static class GankSingletion&#123; private static GankApi mInstance = RetrofitHelper.newRetorfit(BuildConfig.GANK_SERVICE).create(GankApi.class); &#125;&#125; 删除缓存文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class FileUtil &#123; // Interceptor 为保存在SD卡里根目录的文件名 public static final String EXTERNAL_DIRECTORY_NAME = \"Interceptor\"; //判断外部存储是否能用 public static boolean isSDCardAvailable()&#123; String state = Environment.getExternalStorageState(); return Environment.MEDIA_MOUNTED.equals(state); &#125; //获取外部存储的根目录 路径 public static String getSDcardPath() throws IOException&#123; if (isSDCardAvailable())&#123; return Environment.getExternalStorageDirectory().getAbsolutePath(); &#125;else &#123; throw new FileNotFoundException(\"没有外部存储\"); &#125; &#125; /** * 获取程序的外部存储的数据存放根目录 * * @return */ public static String getAppRootDirectoryPath() &#123; if (isSDCardAvailable()) &#123; try &#123; String path = getSDcardPath(); File file = new File(path, EXTERNAL_DIRECTORY_NAME); if (!file.exists()) &#123; file.mkdirs(); &#125; return file.getAbsolutePath(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; //获取外部缓存的地址 public static String getExternalCacheDirectory()&#123; if (isSDCardAvailable())&#123; String path = getAppRootDirectoryPath(); File file = new File(path,\"cache\"); if (!file.exists())&#123; file.mkdirs(); &#125; return file.getAbsolutePath(); &#125; return null; &#125; /** * 删除文件或文件夹 * * @param file * @throws IOException */ public static void deleteFile(File file) throws IOException &#123; if (file.isDirectory()) &#123; for (File f : file.listFiles()) &#123; deleteFile(f); &#125; &#125; else &#123; file.delete(); &#125; &#125;&#125; *log如下123456789101112131408-31 16:33:27.184 9727-10100/com.example.myinterceptor D/OkHttpProvider: Thread: OkHttp http://gank.io/..., intercept(OkHttpProvider.java:92) 发送 request http://gank.io/api/data/%E7%A6%8F%E5%88%A9/10/1 on null08-31 16:33:27.503 9727-10100/com.example.myinterceptor D/OkHttpProvider: Thread: OkHttp http://gank.io/..., intercept(OkHttpProvider.java:95) 收到 response for https://gank.io/api/data/%E7%A6%8F%E5%88%A9/10/1 in 313.3ms ，数据来自网络08-31 16:33:27.503 9727-10100/com.example.myinterceptor D/OkHttpProvider: intercept: null08-31 16:33:27.546 9727-9727/com.example.myinterceptor D/GankPresenter: Thread: main, onResponse(GankPresenter.java:49) 福利干货下载成功： GankResEntity&#123;category=null, error=false, results=&apos;[&#123;_id=5b830bba9d2122031f86ee51, createdAt=2018-08-27T04:21:14.703Z, desc=2018-08-27, publishedAt=2018-08-28T00:00:00.0Z, source=web, type=福利, url=https://ws1.sinaimg.cn/large/0065oQSqly1fuo54a6p0uj30sg0zdqnf.jpg, used=true, who=lijinshanmx&#125;, &#123;_id=5b7b836c9d212201e982de6e, createdAt=2018-08-21T11:13:48.989Z, desc=2018-08-21, publishedAt=2018-08-21T00:00:00.0Z, source=web, type=福利, url=https://ws1.sinaimg.cn/large/0065oQSqly1fuh5fsvlqcj30sg10onjk.jpg, used=true, who=lijinshanmx&#125;, &#123;_id=5b74e9409d21222c52ae4cb4, createdAt=2018-08-16T11:02:24.289Z, desc=2018-08-16, publishedAt=2018-08-16T00:00:00.0Z, source=api, type=福利, url=https://ws1.sinaimg.cn/large/0065oQSqly1fubd0blrbuj30ia0qp0yi.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b7102749d2122341d563844, createdAt=2018-08-13T12:00:52.458Z, desc=2018-08-13, publishedAt=2018-08-13T00:00:00.0Z, source=api, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqly1fu7xueh1gbj30hs0uwtgb.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b6bad449d21226f45755582, createdAt=2018-08-09T10:56:04.962Z, desc=2018-08-09, publishedAt=2018-08-09T00:00:00.0Z, source=web, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqgy1fu39hosiwoj30j60qyq96.jpg, used=true, who=lijinshanmx&#125;, &#123;_id=5b67b7fd9d2122195bdbd806, createdAt=2018-08-06T10:52:45.809Z, desc=2018-08-06, publishedAt=2018-08-06T00:00:00.0Z, source=api, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqly1ftzsj15hgvj30sg15hkbw.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b63cd4e9d21225e0d3f58c9, createdAt=2018-08-03T11:34:38.672Z, desc=2018-08-03, publishedAt=2018-08-03T00:00:00.0Z, source=api, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqgy1ftwcw4f4a5j30sg10j1g9.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b6151509d21225206860f08, createdAt=2018-08-01T14:21:04.556Z, desc=2018-08-01, publishedAt=2018-08-01T00:00:00.0Z, source=api, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqly1ftu6gl83ewj30k80tites.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b60356a9d212247776a2e0e, createdAt=2018-07-31T18:09:46.825Z, desc=2018-07-31, publishedAt=2018-07-31T00:00:00.0Z, source=api, type=福利, url=http://ww1.sinaimg.cn/large/0065oQSqgy1ftt7g8ntdyj30j60op7dq.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b5e93499d21220fc64181a9, createdAt=2018-07-30T12:25:45.937Z, desc=2018-07-30, publishedAt=2018-07-30T00:00:00.0Z, source=web, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqgy1ftrrvwjqikj30go0rtn2i.jpg, used=true, who=lijinshanmx&#125;]&apos;&#125;08-31 16:33:31.205 9727-10100/com.example.myinterceptor D/OkHttpProvider: Thread: OkHttp http://gank.io/..., intercept(OkHttpProvider.java:92) 发送 request http://gank.io/api/data/%E7%A6%8F%E5%88%A9/10/1 on null08-31 16:33:31.581 9727-10100/com.example.myinterceptor D/OkHttpProvider: Thread: OkHttp http://gank.io/..., intercept(OkHttpProvider.java:95) 收到 response for https://gank.io/api/data/%E7%A6%8F%E5%88%A9/10/1 in 388.0ms ，数据来自缓存08-31 16:33:31.581 9727-10100/com.example.myinterceptor D/OkHttpProvider: intercept: Response&#123;protocol=http/1.1, code=200, message=OK, url=https://gank.io/api/data/%E7%A6%8F%E5%88%A9/10/1&#125;08-31 16:33:31.602 9727-9727/com.example.myinterceptor D/GankPresenter: Thread: main, onResponse(GankPresenter.java:49) 福利干货下载成功： GankResEntity&#123;category=null, error=false, results=&apos;[&#123;_id=5b830bba9d2122031f86ee51, createdAt=2018-08-27T04:21:14.703Z, desc=2018-08-27, publishedAt=2018-08-28T00:00:00.0Z, source=web, type=福利, url=https://ws1.sinaimg.cn/large/0065oQSqly1fuo54a6p0uj30sg0zdqnf.jpg, used=true, who=lijinshanmx&#125;, &#123;_id=5b7b836c9d212201e982de6e, createdAt=2018-08-21T11:13:48.989Z, desc=2018-08-21, publishedAt=2018-08-21T00:00:00.0Z, source=web, type=福利, url=https://ws1.sinaimg.cn/large/0065oQSqly1fuh5fsvlqcj30sg10onjk.jpg, used=true, who=lijinshanmx&#125;, &#123;_id=5b74e9409d21222c52ae4cb4, createdAt=2018-08-16T11:02:24.289Z, desc=2018-08-16, publishedAt=2018-08-16T00:00:00.0Z, source=api, type=福利, url=https://ws1.sinaimg.cn/large/0065oQSqly1fubd0blrbuj30ia0qp0yi.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b7102749d2122341d563844, createdAt=2018-08-13T12:00:52.458Z, desc=2018-08-13, publishedAt=2018-08-13T00:00:00.0Z, source=api, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqly1fu7xueh1gbj30hs0uwtgb.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b6bad449d21226f45755582, createdAt=2018-08-09T10:56:04.962Z, desc=2018-08-09, publishedAt=2018-08-09T00:00:00.0Z, source=web, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqgy1fu39hosiwoj30j60qyq96.jpg, used=true, who=lijinshanmx&#125;, &#123;_id=5b67b7fd9d2122195bdbd806, createdAt=2018-08-06T10:52:45.809Z, desc=2018-08-06, publishedAt=2018-08-06T00:00:00.0Z, source=api, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqly1ftzsj15hgvj30sg15hkbw.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b63cd4e9d21225e0d3f58c9, createdAt=2018-08-03T11:34:38.672Z, desc=2018-08-03, publishedAt=2018-08-03T00:00:00.0Z, source=api, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqgy1ftwcw4f4a5j30sg10j1g9.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b6151509d21225206860f08, createdAt=2018-08-01T14:21:04.556Z, desc=2018-08-01, publishedAt=2018-08-01T00:00:00.0Z, source=api, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqly1ftu6gl83ewj30k80tites.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b60356a9d212247776a2e0e, createdAt=2018-07-31T18:09:46.825Z, desc=2018-07-31, publishedAt=2018-07-31T00:00:00.0Z, source=api, type=福利, url=http://ww1.sinaimg.cn/large/0065oQSqgy1ftt7g8ntdyj30j60op7dq.jpg, used=true, who=lijinshan&#125;, &#123;_id=5b5e93499d21220fc64181a9, createdAt=2018-07-30T12:25:45.937Z, desc=2018-07-30, publishedAt=2018-07-30T00:00:00.0Z, source=web, type=福利, url=https://ww1.sinaimg.cn/large/0065oQSqgy1ftrrvwjqikj30go0rtn2i.jpg, used=true, who=lijinshanmx&#125;]&apos;&#125; 这个小栗子在这就介绍完了，但拦截器的学习不会就此打住的，感觉掌握住了它，就能对网路随心所欲把，一大难点啊，哈哈。","tags":[]},{"title":"ViewPager-Fragment页面无限轮播和大小圆点显示","date":"2018-08-17T01:19:46.000Z","path":"2018/08/17/ViewPager-Fragment-大小圆点显示和页面无限轮播/","text":"页面的无限轮播 从字面上了解，就是fragment在ViewPager能自动的无限转换fragment，向右滑动到最后一个fragment时，在滑动则到第一个fragment，向左也是同理，例如下图： 从上图得出，当滑动到5时，则position变为1，当滑动到1时，则position变为5，所以修改list集合代码，如下： 123456fragments.add(new Fragment4()); fragments.add(new Fragment1()); fragments.add(new Fragment2()); fragments.add(new Fragment3()); fragments.add(new Fragment4()); fragments.add(new Fragment1()); 在滑动监听中处理逻辑： 123456789101112131415161718192021222324252627282930313233viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; Log.d(TAG, \"onPageScrolled: \"); &#125; @Override public void onPageSelected(int position) &#123; Log.d(TAG, \"onPageSelected: \" + position); position_1 = position; if (position_1 == fragments.size() - 1)&#123; //如果滑动到最后一个，和第一张相同时，就设置当前值为1 position_1 = 1; &#125;else if (position_1 == 0)&#123; //当滑动到首页时，则和最后一张相同，设置当前值为 倒数第2张的positin值 position_1 = fragments.size() -2; &#125;else &#123; //这时，position_1和position相同 position_1 = position; &#125; &#125; @Override public void onPageScrollStateChanged(int state) &#123; Log.d(TAG, \"onPageScrollStateChanged: \"); //当滑动状态为静止时，设置viewPager的页面 if (state == ViewPager.SCROLL_STATE_IDLE)&#123; viewPager.setCurrentItem(position_1,false); &#125; &#125; &#125;); 效果如下： 自动无限轮播 12345678910111213141516171819202122232425262728293031323334353637383940414243 private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case ONE: if (position_1 &lt; 5)&#123; //position_1的值不能大于5，每次position_1加1 viewPager.setCurrentItem(position_1,false); position_1++; &#125;else &#123; position_1 = 1; viewPager.setCurrentItem(position_1,false); position_1++; &#125; break; default: break; &#125; &#125; &#125;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ..... Timer timer = new Timer(); TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; while (flag) &#123; try &#123; Thread.sleep(2000); Message message = new Message(); message.what = ONE; handler.sendMessage(message); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; timer.schedule(timerTask,0);&#125; 实现小圆点和大圆随fragment的变化而变化； 首先画大小圆点 1234567891011121314151617181920//小圆&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"oval\" android:useLevel=\"false\"&gt; &lt;solid android:color=\"@color/white\"/&gt; &lt;size android:height=\"25dp\" android:width=\"25dp\"/&gt;&lt;/shape&gt;//大圆&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"oval\" android:useLevel=\"false\"&gt; &lt;solid android:color=\"@color/white\"/&gt; &lt;size android:height=\"50dp\" android:width=\"50dp\"/&gt;&lt;/shape&gt; 修改main_activity布局文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.example.mytablayout.viewpager.ViewPagerActivity\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;LinearLayout android:layout_alignParentBottom=\"true\" android:layout_width=\"wrap_content\" android:layout_height=\"50dp\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"40dp\"&gt; &lt;ImageView android:layout_gravity=\"center_vertical\" android:id=\"@+id/one_circle\" android:layout_marginLeft=\"20dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/smallcircle\"/&gt; &lt;ImageView android:layout_gravity=\"center_vertical\" android:id=\"@+id/two_circle\" android:layout_marginLeft=\"20dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/smallcircle\"/&gt; &lt;ImageView android:layout_gravity=\"center_vertical\" android:id=\"@+id/three_circle\" android:layout_marginLeft=\"20dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/smallcircle\"/&gt; &lt;ImageView android:layout_gravity=\"center_vertical\" android:id=\"@+id/four_circle\" android:layout_marginLeft=\"20dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/smallcircle\"/&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 修改java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; Log.d(TAG, \"onPageScrolled: \"); &#125; @Override public void onPageSelected(int position) &#123; Log.d(TAG, \"onPageSelected: \" + position); position_1 = position; if (position_1 == fragments.size() - 1)&#123; //如果滑动到最后一个，和第一张相同时，就设置当前值为1 position_1 = 1; &#125;else if (position_1 == 0)&#123; position_1 = fragments.size() -2; &#125;else &#123; position_1 = position; switch (position_1)&#123; case 1: oneCircle.setBackgroundResource(R.drawable.bigcircle); twoCircle.setBackgroundResource(R.drawable.smallcircle); threeCircle.setBackgroundResource(R.drawable.smallcircle); fourCircle.setBackgroundResource(R.drawable.smallcircle); break; case 2: oneCircle.setBackgroundResource(R.drawable.smallcircle); twoCircle.setBackgroundResource(R.drawable.bigcircle); threeCircle.setBackgroundResource(R.drawable.smallcircle); fourCircle.setBackgroundResource(R.drawable.smallcircle); break; case 3: oneCircle.setBackgroundResource(R.drawable.smallcircle); twoCircle.setBackgroundResource(R.drawable.smallcircle); threeCircle.setBackgroundResource(R.drawable.bigcircle); fourCircle.setBackgroundResource(R.drawable.smallcircle); break; case 4: oneCircle.setBackgroundResource(R.drawable.smallcircle); twoCircle.setBackgroundResource(R.drawable.smallcircle); threeCircle.setBackgroundResource(R.drawable.smallcircle); fourCircle.setBackgroundResource(R.drawable.bigcircle); break; &#125; &#125; &#125; @Override public void onPageScrollStateChanged(int state) &#123; Log.d(TAG, \"onPageScrollStateChanged: \"); if (state == ViewPager.SCROLL_STATE_IDLE)&#123; viewPager.setCurrentItem(position_1,false); &#125; &#125; &#125;); 效果如下：（这里把间隔时间改为500ms） 自此，就全部完成了，是不是很简单，这里主要是方便做笔记，文笔方面比较粗糙，相信在不断的坚持下，肯定会提升的，加油！！！","tags":[]},{"title":"ViewPager Fragment简单页面转换","date":"2018-08-16T08:20:39.000Z","path":"2018/08/16/ViewPager-Fragment-的简单页面转换/","text":"ViewPager Fragment简单页面转换 先来张美女养养神 前言，很早之前就想认真理解ViewPager和Fragment的使用，本文主要是在于记录，方便日后查看。 简单实现ViewPager + Fragment页面的转换 在main_activity布局文件中添加ViewPager控件： 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.example.mytablayout.viewpager.ViewPagerActivity\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 新建4个Fragment，分别为Fragment1、Fragment2、Fragment3、Fragment4，这四个Fragment内容都差不多，就不一一添出来了： 123456789101112131415161718192021222324 //布局内容 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:background=\"@color/blue\" android:textColor=\"@color/white\" android:textSize=\"40sp\" android:text=\"Fragment 1\"/&gt; &lt;/LinearLayout&gt; //java内容 public class Fragment1 extends Fragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_1,container,false); return view; &#125;&#125; 添加Fragment的设配器继承FragmentPagerAdapter： 12345678910111213141516 public class MyFragmentPagerAdapter extends FragmentPagerAdapter &#123; private FragmentManager fragmentManager; List&lt;Fragment&gt; fragments; public MyFragmentPagerAdapter(FragmentManager fm, List&lt;Fragment&gt; fragments) &#123; super(fm); this.fragments = fragments; &#125; @Override public int getCount() &#123; return fragments.size(); &#125; @Override public Fragment getItem(int position) &#123; return fragments.get(position); &#125;&#125; 在MainActivity中的代码实现： 123456789101112131415161718192021222324252627282930313233 public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; List&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;(); private static final String TAG = \"ViewPagerActivity\"; private ViewPager viewPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main_activity); viewPager = findViewById(R.id.viewpager); fragments.add(new Fragment1()); fragments.add(new Fragment2()); fragments.add(new Fragment3()); fragments.add(new Fragment4()); MyFragmentPagerAdapter myFragmentPagerAdapter = new MyFragmentPagerAdapter(getSupportFragmentManager(),fragments); viewPager.setAdapter(myFragmentPagerAdapter); viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; Log.d(TAG, \"onPageScrolled: \"); &#125; @Override public void onPageSelected(int position) &#123; Log.d(TAG, \"onPageSelected: \" + position); &#125; @Override public void onPageScrollStateChanged(int state) &#123; Log.d(TAG, \"onPageScrollStateChanged: \"); &#125; &#125;); &#125;&#125; 效果如下 如此，简单的转换页面的效果已经完成，从代码流程来分析一波，首先，新建一个fragment的适配器类，它继承了FragmentPagerAdapter，以FragmentManager和fragments（List集合对象）为有参构造方法，并重写getCount（）和getItem（）方法。在Activity中通过获取的list集合对象来实例化适配器对象，通过setAdapter()方法，展现出来ViewPager-Fragmnet的简单页面转换功能。","tags":[]},{"title":"RecyclerView-的介绍-三（自定义分割线）","date":"2018-08-13T06:42:19.000Z","path":"2018/08/13/RecyclerView-的介绍-三（自定义分割线）/","text":"RecyclerView的分割线** 从上一篇的之后，我们能完成一个基本的RecyclerView，今天主要来学习RecyclerView的分割线； &nbsp;&nbsp; RecyclerView中自带了一个默认的分割线的调用类，情况如下 1recyclerView.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL)) &nbsp;&nbsp; 因为这个默认的分割线样式太过于简陋，一般我们都会自定义一个分割线来实现我们的需求，下面我们开始自定义一个可以控制方向、颜色、高度的分割线 创建一个ColorDividerItemDecoration类，并继承RecyclerView.ItemDecoration； 使分割线、方向，画笔为全局变量； 12345private float mDividerHeight; private Paint mPaint; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private int mOrientation; 设置一个方向的有参构造方法，并在方法内初始化一些变量； 1234567891011121314public ColorDividerItemDecoration(int orientation) &#123; mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setColor(Color.RED); setOrientation(orientation); &#125; public void setOrientation(int orientation) &#123; if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST)&#123; throw new IllegalArgumentException(\"invalid orientation\"); &#125; mOrientation = orientation; &#125; 重写onDraw方法，判断屏幕横或纵时的逻辑； 123456789101112131415161718192021222324252627282930313233public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); if (mOrientation == VERTICAL_LIST)&#123; drawVertical(c,parent); &#125;else &#123; drawHorizontal(c,parent); &#125; &#125;private void drawVertical(Canvas c, RecyclerView parent) &#123; final float left = parent.getPaddingLeft(); final float right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); final float top = child.getBottom() + params.bottomMargin; final float bottom = top + mDividerHeight; c.drawRect(left,top,right,bottom,mPaint); &#125; &#125; private void drawHorizontal(Canvas c, RecyclerView parent) &#123; float top = parent.getPaddingTop(); float bottom = parent.getHeight() - parent.getPaddingBottom(); int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View child = parent.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); float left = child.getHeight() + params.rightMargin; float right = left + mDividerHeight; c.drawRect(left,top,right,bottom,mPaint); &#125; &#125; 重写getItemOffsets方法，设置item的padding的属性； 12345678@Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); if (parent.getChildAdapterPosition(view) != 0)&#123; outRect.top = 10; mDividerHeight = 10; &#125; &#125; 在mainActivity中调用； 12ColorDividerItemDecoration colorDividerItemDecoration = new ColorDividerItemDecoration(ColorDividerItemDecoration.VERTICAL_LIST);recyclerView.addItemDecoration(colorDividerItemDecoration); &nbsp;&nbsp;本人菜鸟一个，如有不对的地方，请帮忙指出，上面的难点主要在方向的绘制，通过获取到所有的item的个数，根据item的总数来遍历每一个item的位置，绘制出横或纵的分割线；","tags":[]},{"title":"RecyclerView-的介绍-二","date":"2018-07-18T03:43:14.000Z","path":"2018/07/18/RecyclerView-的介绍-二/","text":"RecyclerViewAdapter介绍 在上篇简单的介绍了RecyclerView的使用, 今天主要了解RecyclerViewAdapter 如果没有添加依赖包，一定要先添加； 1implementation 'com.android.support:recyclerview-v7:26.1.0' 创建一个命名为RecyclerViewAdapter的类，继承RecyclerView.Adapter&lt;RecyclerViewAdapter.MyViewHolder&gt;； 1public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.MyViewHolder&gt; 创建MyViewHolder:在Adapter中创建一个继承RecyclerView.ViewHolder的静态内部类，在类里主要初始化item的控件； 1234567class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public MyViewHolder(View itemView) &#123; super(itemView); tv = itemView.findViewById(R.id.tv_item); &#125; &#125; 必须重写onCreateViewHolder、onBindViewHolder、getItemCount这三个方法： onCreateViewHolder()&nbsp; 每生成一个Item时，inflater出一个View,但该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例。 123456 @Override public RecyclerViewAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout_item,parent,false); MyViewHolder holder = new MyViewHolder(view); return holder;&#125; onBindViewHolder()&nbsp; 这个方法主要用于渲染数据到View中。方法提供给你你一个viewHolder,而不是原来的convertView。 12345@Override public void onBindViewHolder(HomeAdapter.MyViewHolder holder, int position) &#123; holder.itemView.setTag(position); holder.tv.setText(mList.get(position)); &#125; getItemCOunt()&nbsp; 这个方法类似于BsaeAdapter的getCount,获取总共有多少个Item。 至此，到这里就结束了，如果上述有歧义的地方，请及时联系作者；这已经是第三篇了，虽然内容都很基础，但还是感到很充足，把自己学到的东西分享出去，很激动，兴奋，虽然有些微不足道；嘻嘻，加油，坚持！ 题外话，昨天晚上有点伤感吧，通过众筹得知一位小学同学得了白血病，虽然还是８年前的一次小学同学聚会看到过一次，但现在脑海里立马能呈现出当时那个阳光健康的大男孩；带着这份沉重的心情，看完了你在前几次化疗，从希望到失望，到现在的绝望，但你依然每次都不放过任何一个生存的希望，我为你骄傲，加油吧，老同学！ 眼睛进沙了，今天先到这了，下期再见 非淡泊无以明志 非宁静无以致远","tags":[]},{"title":"RecyclerView 的介绍(一)","date":"2018-07-13T09:55:09.000Z","path":"2018/07/13/RecyclerView-的介绍-一/","text":"美女镇楼 RecyclerView是什么？&nbsp;&nbsp;从android5.0开始，谷歌公司推出了一个用于大量数据展示的新控件RecyclerView，可以代替传统的ListView,它具有高度的解耦、异常灵活和更高的效率，通过设置它提供的不同的LayoutManager、ItemDecoration、ItemAnimator可是实现更加丰富多样的效果。 配置BUild.gradle&nbsp;&nbsp; 使用Recycleriew之前，我们得先导入support-v7包(android studio)12345dependencies&#123;... complie 'com.android.support:appcompat-v7:22.2.0' complie 'com.android.support:recyclerview-v7:22.2.0'&#125; 使用RecyclerView&nbsp;&nbsp; 修改main_activity.xml中的代码,具体如下1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp; 然后新建activity_recycler_view.xml如下：123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_item\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:background=\"@android:color/white\" /&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp; 和listView的Adapter相比，Adapter最大的改进就是对ViewHolder进行了封装定义再次，自定义一个ViewHolder继承RecyclerView.ViewHolder;下面来一个实例：12345678910111213141516171819202122232425262728293031323334353637383940414243public class HomeAdapter extends RecyclerView.Adapter&lt;HomeAdapter.MyViewHolder&gt; &#123; private List&lt;String&gt; mList; private Context mContext; public HomeAdapter(List&lt;String&gt; mList, Context mContext) &#123; this.mList = mList; this.mContext = mContext; &#125; public void removeData(int position)&#123; mList.remove(position); notifyItemRemoved(position); if (position != mList.size())&#123; notifyItemRangeChanged(position,mList.size() - position); &#125; &#125; @Override public HomeAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_recycler,parent,false); MyViewHolder holder = new MyViewHolder(view); return holder; &#125; @Override public void onBindViewHolder(HomeAdapter.MyViewHolder holder, int position) &#123; holder.itemView.setTag(position); holder.tv.setText(mList.get(position)); &#125; @Override public int getItemCount() &#123; return mList.size(); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public MyViewHolder(View itemView) &#123; super(itemView); tv = itemView.findViewById(R.id.tv_item); &#125; &#125;&#125; &nbsp;&nbsp;在mainActivity的onCreate方法中实例化RecyclerView、LinearLayoutManager、HomeAdapter,实例如下：1234567891011 RecyclerView recycler = findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this); HomeAdapter adapter = new HomeAdapter(mList,this);//默认条目样式为垂直排列layoutManager.setOrientation(LinearLayoutManager.VERTICAL);//条目样式为水平排列//layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); recycler.setLayoutManager(layoutManager);//设置Item增加和删除时的动画 recycler.setItemAnimator(new DefaultItemAnimator()); recycler.setAdapter(adapter); &nbsp;&nbsp; 最后显示效果如下: &nbsp;&nbsp; 至此，一个简单的RecyclerView就完成了，下一篇主要分析自定义Adapter中的重写方法，点击事件。今天暂时告一段落，下期不见不散。 &nbsp;&nbsp; 非淡泊无以明志 非宁静无以致远!","tags":[]},{"title":"android-Activity的生命周期详解","date":"2018-07-06T09:55:09.000Z","path":"2018/07/06/android-Activity的生命周期详解/","text":"美女镇楼 什么是activity?&nbsp;&nbsp;众所周知，activity是android的四大组件之一，它在Andeoid中代表了界面和以界面为中心的相应的业务逻辑，包括显示、与用户交互等。一个应用程序通常由多个activity组成，当用户打开的第一个界面我们称为activity，其中activity之间的通信是intent。今天我们主要了解的生命周期，下图是它从出生到销毁的全过程: 活动状态 运行状态：当一个活动位于返回栈的栈顶时，这时活动处于运行状态; 暂停状态：当一个活动不再处于栈顶位置时，但仍然可见时，这时活动就进入了暂停状态;(对话框形式) 停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态 销毁状态：当一个活动从返回栈中移除后就变成了销毁状态。 Activity的７个回调方法 onCreate()：该方法是在activity被创建时回调，它是生命周期的第一个回调方法，我们在创建activity的时候一般都要重写该方法，主要在其中做一些初始化的操作，如通过SetContentView设置界面布局资源，初始化所需要的控件。 onStart()：回调此方法时，表明activity已处于可见状态，只是还没有在前台显示，因此无法与用户进行交互。 onResume()：调用此方法时，则说明activity已在前台可见，可与用户交互了。它与onStrat()方法相同处是回调两者时，activity都是可见的，只是一个与用户不能交互，一个能与用户交互。 onPause()：回调此方法时，表示activity正在停止，如弹出一个框时，会执行onPause()-&gt;onStop()方法。 onstop()：回调此方法，一般在onPause()方法执行完后执行，表示activity即将停止或完全覆盖，此时activity不可见，仅在后台运行。 onDestroy()：回调此方法，说明activity正在被销毁，在此方法中我们一般做一些回收工作和最终资源的释放。 onRestart()：当activity正在重新启动，由不可见变成可见的状态时，回调此方法。 &nbsp;&nbsp; 上面７个方法中，除了onRestart(),其他都是两两相对的，如：onCreate和onDestroy(完整生存期)、onStart和onStop(可见生存期)、onResume和onPause(前台生存期)。 体验activity生命周期&nbsp;&nbsp; 屁话说了一大堆，下面我们通过一个实例来更直观的体验activity的生命周期。 &nbsp;&nbsp;首先我们新建一个项目，再分别创建两个子活动——NormalActivity和DialogActivity;创建完成之后，分别把normal_activity.xml和diglog_activity.xml里的代码替换如下内容;12345678910111213141516171819&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"This is a normal activity\"/&gt;&lt;/LinearLayout&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"This is a dialog activity\"/&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp;然后修改AndroidManifest.xml的配置android:theme=”@style/Theme.AppCompat.Dialog”1234567891011&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".NormalActivity\" /&gt; &lt;activity android:name=\".DialogActivity\" android:theme=\"@style/Theme.AppCompat.Dialog\"&gt; &lt;/activity&gt; &nbsp;&nbsp; 修改main_activity.xml,如下：1234567891011121314&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/start_normal_activity\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Start NormalActivity\" /&gt; &lt;Button android:id=\"@+id/start_dialog_activity\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Start DialogActivity\" /&gt;&lt;/LinearLayout&gt; &nbsp;&nbsp;最后修改main_activity的代码，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainActivity extends AppCompatActivity &#123; private static final String TAG = \"MainActivity\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, \"onCreate: \"); setContentView(R.layout.activity_main); findViewById(R.id.start_normal_activity).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,NormalActivity.class)); &#125; &#125;); findViewById(R.id.start_dialog_activity).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,DialogActivity.class)); &#125; &#125;); &#125; @Override protected void onStart() &#123; super.onStart(); Log.d(TAG, \"onStart: \"); &#125; @Override protected void onResume() &#123; super.onResume(); Log.d(TAG, \"onResume: \"); &#125; @Override protected void onPause() &#123; super.onPause(); Log.d(TAG, \"onPause: \"); &#125; @Override protected void onStop() &#123; super.onStop(); Log.d(TAG, \"onStop: \"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.d(TAG, \"onDestroy: \"); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.d(TAG, \"onRestart: \"); &#125;&#125; &nbsp;&nbsp;现在运行这个程序，这是logcat中的打印日志，从下图可以看到程序开启后会执行onCreate() -&gt; onStart() -&gt; onResume()。 &nbsp;&nbsp;启动NormalActivity后，会把MainActivity完全遮住，因此执行onPause() -&gt; onStop(),此时不会执行onCreate(),因为activity没有重建。 &nbsp;&nbsp;点击返回键，返回MainActivity,执行onRestart() -&gt; onStart() -&gt; onResume() &nbsp;&nbsp;启动DialogActivity后,执行onPause()方法，因为DialogActivity并没有完全遮挡住MainActivity，此时MainActivity只是进入了暂停状态，并没有进入停止状态。 &nbsp;&nbsp;相应的，我们按下返回键,再一次返回MainActivity,这是只有onResume()方法会执行 &nbsp;&nbsp;最后，在MainActivity下按返回键退出程序，执行onPause() -&gt; onStop() -&gt; onDestroy()。 到这里我们来个小结：当Activity启动时，依次会调用onCreate(),onStart(),onResume()；当Activity退居后台时（不可见，被新的Activity完全覆盖），onPause()和onStop()会依次被调用；当Activity重新回到前台（或者被覆盖后又回到原Activity）时，onRestart()，onStart()，onResume()会依次被调用；当Activity退出销毁时（点击back键），onPause()，onStop()，onDestroy()会依次被调用，到此Activity的整个生命周期方法回调完成。至此，activity的生命周期以介绍完成，往后继续更新博客，对自己所学的知识进行梳理。加油！加油！ &nbsp;&nbsp; 非淡泊无以明志 非宁静无以致远","tags":[]}]